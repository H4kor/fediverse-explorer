<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script defer data-domain="h4kor.github.io/fediverse-explorer" src="https://plausible.libove.org/js/plausible.js"></script>
    <title>Fediverse Explorer</title>
</head>
<body style="margin: 0; padding: 0; overflow: hidden;height: 100vh;background-color: #191b22; color: white">
    <h1>FediExplorer</h1>
    <div>Search: <input type="text" id="searchBox"><p id="result"></p></div>
    <svg id="chart" width="100%" height="100%"></svg>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        // search function
        document.getElementById("searchBox").onkeydown = function(e) {
            if (event.key == "Enter") {
                if (!highlightNode(e.target.value)) {
                    document.getElementById('result').textContent = "could not exactly match for node";
                } else {
                    document.getElementById('result').textContent = "";
                }
            }
        };

        // init box
        const min_x = -0.02;
        const max_x = 0.07;
        const min_y = 0.02;
        const max_y = 0.12;

        const svg = d3.select("#chart");

        const width = svg.node().getBoundingClientRect().width;
        const height = svg.node().getBoundingClientRect().height;
        const aspect = width / height;

        let zoom = d3.zoom()
            .on('zoom', handleZoom);

        var searchNode = null;
        
        function zoomTo(x, y) {
            // FIXME: broken, copied from examples where the handlers are different
            let transform = d3.zoomIdentity.translate(x, y);
            let zoomBase = d3.select('svg');
            // FIXME: this updates the data correctly but does not cause any animation
            zoomBase
                .transition()
                .duration(5000)
                .call(zoom.transform, transform);
        }

        function handleZoom(e) {
            d3.select('svg g')
                .attr('transform', e.transform);
        }

        function initZoom() {
            d3.select('svg')
                .call(zoom);
        }

        function highlightNode(name) {
            let nodeName = name.replaceAll(".", "\\.");
            let node = d3.select("#node-"+nodeName).node();
            if (node == null) {
                console.log("cannot find node id: node-" + name);
                return false;
            }
            if (searchNode != null) {
                d3.select(searchNode).attr('mark', 'false');
                recolorNode(searchNode);
            }
            searchNode = node;
            d3.select(node).attr('mark', 'true');
            recolorNode(node);
            text.text(name);
            return true;
        }

        function recolorNode(node) {
            if (d3.select(node).attr('select') == 'true') {
                // highlighted by mouse over
                d3.select(node).attr("fill", "#00aaFF").attr("opacity", 1);
            } else if (d3.select(node).attr('mark') == 'true') {
                // highlighted by search
                d3.select(node).attr("fill", "#FF0000").attr("opacity", 1);
            } else {
                // regular node
                d3.select(node).attr("fill", "#ddaa00").attr("opacity", 0.5);
            }
        }

        const g = svg.append("g");
        
        const text = svg.append("text")
            .attr("x", 5)
            .attr("y", 29)
            .attr("font-size", "24px")
            .attr("font-family", "monospace")
            .attr("font-weight", "bold")
            .attr("fill", "white")
            .attr("stroke", "black")
            .attr("stroke-width", "1px")
            .text("");

        d3.json("data.json").then(function(json) {
            g.selectAll("circle")
                .data(json)
                .enter()
                .append("circle")
                .attr("id", function(d) { return "node-" + d[0] })
                .attr("cx", function(d) { return (d[1][0] - min_x) / (max_x - min_x) * Math.min(width, height); })
                .attr("cy", function(d) { return (d[1][1] - min_y) / (max_y - min_y) * Math.min(width, height); })
                .attr("r", 1)
                .attr("opacity", 0.5)
                .attr("fill", "#ddaa00")
                .on("click", function(e, d) {
                   console.log(d[0]);
                   text.text(d[0]);
                   if(searchNode != null) {
                       d3.select(searchNode).attr('mark', 'false')
                       recolorNode(searchNode)
                       searchNode = null;
                   }
                })
                .on("mouseover", function(e, d) {
                    d3.select(this).attr('select', 'true')
                    recolorNode(this)
                })
                .on("mouseout", function(e, d) {
                    d3.select(this).attr('select', 'false')
                    recolorNode(this)
                });
            initZoom();        
        });
    </script>
</body>
</html>